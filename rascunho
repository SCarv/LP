dimensao(3). 

/*

notar!!! Este eh o numero de linhas/colunas do puzzle. O puzzle eh sempre quadrado.

Para alterar a dimensao do puzzle basta substituir aqui

a dimensao do novo puzzle.

*/





mov_legal(Tabuleiro1, _, Peca, Tabuleiro2) :-	





	mov_direita(Tabuleiro1, d, Peca, Tabuleiro2);



	mov_baixo(Tabuleiro1, b, Peca, Tabuleiro2);



	mov_esquerda(Tabuleiro1, e, Peca, Tabuleiro2);



	mov_cima(Tabuleiro1, c, Peca, Tabuleiro2).





mov_esquerda(Tabuleiro1, e, Peca, Tabuleiro2) :- 



	

	dimensao(Dim), nonvar(Tabuleiro1) ->

		( nth1(Indice_0, Tabuleiro1, 0), %instancia Indice_0 e Resto1

		Indice_0 mod Dim =\= 0, %nao pode ocorrer translineacao

		Indice_P is Indice_0 + 1, %instancia Indice_P

		nth1(Indice_P, Tabuleiro1, Peca, Resto), %instancia P e Resto2

		nth1(Indice_0, Tabuleiro2, Peca, Resto) ).


/*	dimensao(Dim), nonvar(Tabuleiro2) ->

		nth1(Indice_P, Tabuleiro2, 0, Resto2)

		

	%decremento de 1 faz sentido para qualquer dimensao do tabuleiro! */



mov_ilegal :- write('movimento ilegal!').





mov_direita(Tabuleiro1, d, Peca, Tabuleiro2) :- 



	dimensao(Dim), nonvar(Tabuleiro1) ->

		nth1(Indice_0, Tabuleiro1, 0), %instancia Indice_0 e Resto1

		Indice_0 =\= 1,

		Indice_0 mod Dim =\= 1, %nao pode ocorrer translineacao

		Indice_P is Indice_0 - 1, %instancia Indice_P

		nth1(Indice_P, Tabuleiro1, Peca, Resto), %instancia P e Resto2

		nth1(Indice_0, Tabuleiro2, Peca, Resto).



mov_baixo(Tabuleiro1, b, Peca, Tabuleiro2) :-



	dimensao(Dim), nonvar(Tabuleiro1) ->

		nth1(Indice_0, Tabuleiro1, 0),

		Indice_0 > Dim,

		Indice_P is Indice_0+Dim,

		nth1(Indice_P, Tabuleiro1, Peca, Resto),

		nth1(

